package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/fs"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
)

func main() {
	var (
		rootModules = flag.String("modules", "internal/modules", "modules root to scan")
	)
	flag.Parse()

	modulePath, err := getModulePath()
	if err != nil {
		log.Fatalf("Error determining module path: %v", err)
	}

	routesDirs, err := findRoutePackages(*rootModules)
	if err != nil {
		log.Fatalf("Error finding route packages: %v", err)
	}

	imports := toImportPaths(routesDirs, modulePath)
	sort.Strings(imports)

	code := renderImportsFile(imports)
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code to help debug.
		formatted = []byte(code)
	}

	outPath := filepath.Join(*rootModules, "zz_routes_imports.go")
	if err := writeIfChanged(outPath, formatted); err != nil {
		log.Fatalf("Error writing imports file: %v", err)
	}
}

func getModulePath() (string, error) {
	cmd := exec.Command("go", "list", "-m")
	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("could not determine module path (is this a Go module?): %w\n%s", err, stderr.String())
	}
	return strings.TrimSpace(out.String()), nil
}

func findRoutePackages(root string) ([]string, error) {
	var dirs []string
	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			// Propagate errors so the tool fails clearly if it can't read a directory.
			return err
		}
		if d.IsDir() {
			name := d.Name()
			if name == ".git" || name == "node_modules" || name == "vendor" || strings.HasPrefix(name, ".") {
				return filepath.SkipDir
			}
			// Look for .../http/routes directory
			if strings.HasSuffix(filepath.ToSlash(path), "/http/routes") {
				// Ensure it has at least one non-test .go file
				entries, err := os.ReadDir(path)
				if err != nil {
					// Propagate the error so the tool fails instead of silently skipping a module.
					return err
				}
				for _, e := range entries {
					if e.IsDir() {
						continue
					}
					name := e.Name()
					if strings.HasSuffix(name, ".go") && !strings.HasSuffix(name, "_test.go") {
						dirs = append(dirs, path)
						break
					}
				}
			}
		}
		return nil
	})
	return dirs, err
}

func toImportPaths(dirs []string, moduleRoot string) []string {
	imports := make([]string, 0, len(dirs))
	for _, d := range dirs {
		// The path `d` is already relative to the project root.
		imp := filepath.ToSlash(filepath.Join(moduleRoot, d))
		imports = append(imports, imp)
	}
	return imports
}

func renderImportsFile(imports []string) string {
	var b bytes.Buffer
	b.WriteString("// Code generated by genroutes; DO NOT EDIT.\n")
	b.WriteString("package modules\n\n")
	b.WriteString("import (\n")
	b.WriteString("\t// Ensure module routes init() self-register with the registry.\n")
	for _, imp := range imports {
		fmt.Fprintf(&b, "\t_ %q\n", imp)
	}
	b.WriteString(")\n")
	return b.String()
}

func writeIfChanged(path string, data []byte) error {
	existing, err := os.ReadFile(path)
	if err == nil {
		if bytes.Equal(existing, data) {
			return nil // no change
		}
	}
	return os.WriteFile(path, data, 0o644)
}
