// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.943
package pages

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

// ChatPage renders the main interface for the real-time chat and game state monitor.
func ChatPage() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div class=\"container mx-auto p-4 h-screen flex flex-col bg-white shadow-xl rounded-2xl\" hx-ext=\"ws\" ws-connect=\"/app/ws/html?publish_topic=chat.messages.new\"><h1 class=\"text-3xl font-extrabold mb-6 text-gray-900 border-b pb-2\">Real-time Chat with Data Stream</h1><!-- 1. CHAT MESSAGES CONTAINER --><div id=\"chat-messages\" class=\"flex-grow overflow-y-auto border border-gray-200 rounded-lg p-4 mb-4 bg-gray-50 shadow-inner space-y-3\"><!-- Initial message or placeholder --><div class=\"text-sm text-gray-500 italic p-1\">Welcome to the chat! Messages will appear here.</div></div><!-- 2. FORM FOR SENDING MESSAGES --><form id=\"chat-form\" hx-post=\"/app/chat/message\" hx-swap=\"none\" class=\"flex gap-3\"><input type=\"text\" name=\"content\" class=\"input input-bordered flex-grow p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 shadow-sm\" placeholder=\"Type a message...\" autofocus autocomplete=\"off\" required> <button type=\"submit\" class=\"btn btn-primary bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-150 shadow-md\">Send</button></form><!-- 3. GAME STATE MONITOR (Separate Data Stream) --><div class=\"mt-6 p-4 border border-gray-700 rounded-lg bg-gray-800 text-white font-mono text-sm shadow-xl\"><div class=\"flex justify-between items-center mb-3\"><h3 class=\"font-bold text-lg text-yellow-400\">Game State Monitor (WS Data)</h3><button class=\"btn btn-xs btn-warning bg-yellow-500 text-gray-900 font-bold py-1 px-3 rounded-full hover:bg-yellow-600 transition duration-150\" hx-get=\"/app/debug/hit\" hx-swap=\"none\">Trigger Hit Event</button></div><div id=\"game-state-display\" class=\"text-gray-300\">-- Waiting for data from /app/ws/data --</div></div><!-- 4. INLINE JAVASCRIPT LOGIC --><script>\n\t\t\t// A little bit of JS to clear the input after a message is sent via WebSocket\n\t\t\t// We listen for htmx:afterRequest which fires after a successful POST.\n\t\t\tdocument.body.addEventListener(\"htmx:afterRequest\", function (evt) {\n\t\t\t\t// Check if the event was triggered by our chat form\n\t\t\t\tif (evt.detail.elt.id === \"chat-form\") {\n\t\t\t\t\tdocument.querySelector('#chat-form input[name=\"content\"]').value = \"\";\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// --- Auto-scrolling for the chat container ---\n\t\t\tconst chatContainer = document.getElementById(\"chat-messages\");\n\t\t\t// Listen for the htmx event that fires after an out-of-band swap.\n\t\t\tdocument.body.addEventListener(\"htmx:oobAfterSwap\", function (evt) {\n\t\t\t\t// We check if the swap target was our chat messages container, or if a child element of it was swapped.\n\t\t\t\tif (evt.detail.target && evt.detail.target.id === \"chat-messages\") {\n\t\t\t\t\t// Scroll the container to the bottom to show the new message.\n\t\t\t\t\t// Use a slight delay (0ms) to ensure the DOM update is fully painted before scrolling.\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tchatContainer.scrollTop = chatContainer.scrollHeight;\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// --- JavaScript Island for the Data WebSocket ---\n\t\t\tconst gameStateDisplay = document.getElementById(\"game-state-display\");\n\t\t\t// Determine the correct WebSocket protocol (ws or wss) based on the page's protocol.\n\t\t\tconst wsProtocol = window.location.protocol === \"https:\" ? \"wss\" : \"ws\";\n\t\t\tconst dataSocket = new WebSocket(\n\t\t\t\t`${wsProtocol}://${window.location.host}/app/ws/data`\n\t\t\t);\n\n\t\t\tdataSocket.onopen = function (event) {\n\t\t\t\tconsole.log(\"Data WebSocket connection established.\");\n\t\t\t\tgameStateDisplay.textContent =\n\t\t\t\t\t\"Connection to /app/ws/data established. Waiting for events...\";\n\t\t\t};\n\n\t\t\tdataSocket.onmessage = function (event) {\n\t\t\t\ttry {\n\t\t\t\t\tconst data = JSON.parse(event.data);\n\t\t\t\t\tconsole.log(\"Received data:\", data);\n\n\t\t\t\t\t// Check if it's a damage event and update the display for any unit.\n\t\t\t\t\tif (data.eventType === \"damage\") {\n\t\t\t\t\t\tgameStateDisplay.textContent = `Unit '${data.unitId}' took ${data.damageTaken} damage. New Health: ${data.newHealth}`;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to parse incoming data message:\", e);\n\t\t\t\t\tgameStateDisplay.textContent = \"Error processing data from server.\";\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tdataSocket.onclose = function (event) {\n\t\t\t\tconsole.log(\"Data WebSocket connection closed.\");\n\t\t\t\tgameStateDisplay.textContent = \"Connection to /app/ws/data closed.\";\n\t\t\t};\n\t\t</script></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
